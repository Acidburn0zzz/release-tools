#!/bin/perl

# Copyright 2011 Chris Nighswonger
#
# This is free software; you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# This is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# Koha; if not, write to the Free Software Foundation, Inc., 59 Temple Place,
# Suite 330, Boston, MA  02111-1307 USA
#

use strict;
use warnings;

use POSIX qw(strftime);
use LWP::Simple;
use Text::CSV;


# TODO:
#   1. Paramatize!
#   2. Add optional verbose output
#   3. Add exit status code

# git log --pretty=format:'%s' v3.04.05..HEAD | grep -Eo '([B|b]ug|BZ)?(\s|:|-|_|,)?\s?[0-9]{4}\s' | grep -Eo '[0-9]{4}' -  | sort -u 

my @bug_list = ();
my @git_log = qx|git log --pretty=format:'%s' v3.04.05..HEAD|;

foreach (@git_log) {
    if ($_ =~ m/([B|b]ug|BZ)?\s?(?<![a-z]|\.)(\d{4})[\s|:|,]/g) {
#        print "$&\n"; # Uncomment this line and the die below to view exact matches
        push @bug_list, $2;
    }
}
#die "Done for now...\n"; #XXX
@bug_list = sort {$a <=> $b} @bug_list;

my $url = "http://bugs.koha-community.org/bugzilla3/buglist.cgi?order=bug_severity%2Cbug_id&content=";
$url .= join '%2C', @bug_list;
$url .= "&ctype=csv";

my @csv_file = split /\n/, get($url);
my $csv = Text::CSV->new();

# Extract the column names
$csv->parse(shift @csv_file);
my @columns = $csv->fields;

my $highlights = '';
my $bugfixes = '';

while (scalar @csv_file) {
    $csv->parse(shift @csv_file);
    my @fields = $csv->fields;
    if ($fields[1] =~ m/(blocker|critical|major)/) {
        $highlights .= "$fields[0]\t$fields[1]" . ($1 =~ /blocker|major/ ? "\t\t" : "\t") ."$fields[7]\n";
    }
    elsif ($fields[1] =~ m/(normal|enhancement)/) {
        $bugfixes .= "$fields[0]\t$fields[1]" . ($1 eq 'normal' ? "\t\t" : "\t") ."$fields[7]\n";
    }
}

# I'm not sure why opening this +> mode does not work, but we end up with an empty file

open (RNOTES, "< misc/release_notes/release_notes_3_4_6.txt");
my @release_notes = <RNOTES>;
close RNOTES;

open (RNOTES, "> misc/release_notes/release_notes_3_4_6.txt");

foreach my $line (@release_notes) {
    if ($line =~ m/<<(.+)>>/) { # why?
        #   Find and replace template markers
        if ($1 eq 'highlights') {
            $line =~ s/<<highlights>>/$highlights/;
        }
        elsif ($1 eq 'bugfixes') {
            $line =~ s/<<bugfixes>>/$bugfixes/;
        }
        elsif ($1 eq 'contributors') {
            # Now we'll alphabetize the contributors based on surname (or at least the last word on their line)
            # WARNING!!! Obfuscation ahead!!!
            my @contributor_list =
                map { $_->[1] }
                sort { $a->[0] cmp $b->[0] }
                map { [(split /\s+/, $_)[scalar(split /\s+/, $_)-1], $_] }
                qx(git log --pretty=short v3.04.05..HEAD | git shortlog -s | sort -k3 -);

            my $contributors = join "", @contributor_list;
            $line =~ s/<<contributors>>/$contributors/;
        }
        else {
        }
    }
    # Update version numbers
    if ($line =~ m/3\.4\.5/g) {
        $line =~ s/3\.4\.5/3\.4\.6/g;
    }
    if ($line =~ m/3\.04\.05/g) {
        $line =~ s/3\.04\.05/3\.04\.06/g;
    }
    # Update date
    if ($line =~ m/((0?[1-9]|[1-2][0-9]|3[01])\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(19[0-9]{2}|[2-9][0-9]{3}|[0-9]{2}))/g) {
        my $current_date = strftime "%d %b %Y", gmtime;
        $line =~ s/((0?[1-9]|[1-2][0-9]|3[01])\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(19[0-9]{2}|[2-9][0-9]{3}|[0-9]{2}))/$current_date/g;
    }
    print RNOTES "$line";
}

# FIXME: This needs to check for and replace existing autogenerated blurbs!!
# Add autogenerated blurb to the bottom
print RNOTES "\n##### Autogenerated release notes updated last on " . strftime("%d %b %Y", gmtime) . " at ". strftime("%T", gmtime)  ."Z #####";

close RNOTES;


# FIXME: This needs test logic
#unless (-e 'misc/release_notes/release_notes_3_4_6.txt') {
    print "Adding file to repo...\n";
    my @add_results = qx|git add misc/release_notes/release_notes_3_4_6.txt|;
#}

print "Commiting changes...\n";
my @commit_results = qx|git commit -m "Release Notes for 3.04.06.000" misc/release_notes/release_notes_3_4_6.txt|;
